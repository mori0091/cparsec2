# -*- coding: utf-8-unix -*-
#+STARTUP: showall indent

* API Reference

*Table of Contents*

- [[#core-api][Core API]] :: 
  - CPARSEC2 core APIs
  - Exception handling API for C.
  - Containers
    - ~List(T)~ - a list container
    - Iteration API for ~List(T)~
    - ~Buff(T)~ - a list builer
    - List builder API for ~Buff(T)~
- [[#type-of-parsers][Type of Parsers]] ::
  - PARSER(Char)
  - PARSER(String)
  - PARSER(Int)
  - PARSER(List(Char))
  - PARSER(List(String))
  - PARSER(List(Int))
- [[#built-in-parsers-parser-generators-and-parser-combinators][Built-in Parsers, Parser generators, and Parser combinators]] ::
  - Built-in Parsers and Parser-generators
  - Built-in *GENERIC* Parser-combinators
- [[#building-block-of-parser-class][Building block of Parser-class]] ::
  - PARSER(T) class
  - Declare and Define PARSER(T) class
  - Construct an instance of PARSER(T)
  - Apply an instance of PARSER(T) to a text

* Core API
:PROPERTIES:
:CUSTOM_ID: core-api
:END:

** CPARSEC2 core APIs
:PROPERTIES:
:CUSTOM_ID: cparsec2-core-apis
:END:

- cparsec2_init()       :: 
     Initialize cparsec2 library.\\
     This must be called once at first.
- cparsec2_end()        :: 
     Clean up cparsec2 library. (deallocate all allocated memory)\\
     During after calling this API and before calling ~cparsec2_init()~, calling
     any other cparsec2 API and values returned from them are invalid (access to
     them will be undefined behavior).
- parse(p, src, ctx)    :: 
     Apply parser ~p~ to text provided from ~src~, and return result (such as
     ~char~, ~const char *~). If an error occurred, it is thrown as exception
     through ~ctx~. (see also [[#exception-handling][Exception handling]])
- parseTest(p, text)    :: 
     Apply parser ~p~ to ~text~ and print result.\\
     Return ~true~ if passed, ~false~ if failed.
- PARSE_TEST(p, text) :: 
     Same as ~parseTest~ and also print ~p text~. (for debug purpose)\\
     Return ~true~ if passed, ~false~ if failed.

** Exception handling
:PROPERTIES:
:CUSTOM_ID: exception-handling
:END:

- Ctx                   :: 
     Type of context for exception handling.
- TRY(ctx) {...} else {...} :: 
     Exception handling macro. (C++ or Java like ~try {...} catch {...}~ clause)
- cthrow(ctx, msg)      :: 
     Throw a string ~msg~ as an exception.

Example:
#+begin_src c
  Ctx ctx;
  TRY(&ctx) {                        /* try */
    // ...
    cthrow(&ctx, "something wrong!"); /* throw "something wrong!" */
    // ...
  }
  else {                             /* catch */
    printf("error:%s\n", ctx.msg);   /* -> "error: something wrong!" */
    mem_free(ctx.msg);
  }
#+end_src

** Containers
:PROPERTIES:
:CUSTOM_ID: containers
:END:

*** List(T) - a list container
~List(T)~ is a Generic type of list container.\\
To construct a ~List(T)~ object, use list-builder ~Buff(T)~.

- List(Char)          ::
     A type of a list container whose element type is ~const char~.
- List(String)        ::
     A type of a list container whose element type is ~const char*~.
- List(Int)           ::
     A type of a list container whose element type is ~int~.
- List(Ptr)           ::
     A type of a list container whose element type is ~void*~.

*NOTE* : ~List(Char)~ is same as ~const char*~ (i.e. string in C)

*** Iteration API for List(T)
To iterate elements contained in a ~List(T)~ object, use the following APIs.\\
*NOTE* : ~E~ is the element type of ~List(T)~ object.

- E* list_begin(List(T) xs) ::
   Retunrs an iterator, which points to the 1st element of the list. (inclusive)

- E* list_end(List(T) xs)   ::
   Returns an iterator, which points to the next of the last element. (out of range)

- int list_length(List(T) xs) ::
   Returns the number of elements.\\

*NOTE* : list_begin(xs) + list_length(xs) == list_end(xs)

For example:
#+begin_src c
  /* a null-terminated char sequence is also a List(Char) */
  List(Char) xs = "abcdefg";

  const char* itr = list_begin(xs);
  const char* end = list_end(xs);
  while (itr != end) {
    printf("%c\n", *itr);
    itr++;
  }
#+end_src

*** Buff(T) - a list builder
~Buff(T)~ is a generic type of list builder.\\
It is a variadic length buffer to build a ~List(T)~ object.

- Buff(Char)         ::
     A type of a list-builder whose element type is ~char~.
- Buff(String)       ::
     A type of a list-builder whose element type is ~const char*~.
- Buff(Int)          ::
     A type of a list-builder whose element type is ~int~.
- Buff(Ptr)          ::
     A type of a list-builder whose element type is ~void*~.

*** List builder API for Buff(T)
To build a ~List(T)~ object, use the following APIs:\\
*NOTE* : ~E~ is the element type of ~Buff(T)~ object and resulting ~List(T)~ object.

- void buff_push(Buff(T)* buf, E x) ::
     Adds an element ~x~ to the last of ~buf~.
- void buff_append(Buff(T)* buf, List(T) xs) ::
     Adds elements in the ~xs~ to the last of ~buf~.
- List(T) buff_finish(Buff(T)* buf) ::
     Creates a ~List(T)~ object and clear contents of ~buf~.

For example:
#+begin_src c
  /* A Buff(T) object must be initialized with {0} at first. */
  Buff(Int) buf = {0};

  for (int i = 0; i < 10; ++i) {
    buff_push(&buf, i);
  }
  List(Int) xs = buf_finish(&buf);

  int* itr = list_begin(xs);
  int* end = list_end(xs);
  while (itr != end) {
    printf("%d", *itr++);         /* -> "0123456789" */
  }
  printf("\n");
#+end_src


* Type of Parsers
:PROPERTIES:
:CUSTOM_ID: type-of-parsers
:END:

- PARSER(Char)            ::
  A parser of ~PARSER(Char)~ type reads one char, and \\
  returns a ~char~ value, when it is applied to a text.
- PARSER(String)          ::
  A parser of ~PARSER(String)~ type reads chars, and \\
  returns a ~const char*~ value, when it is applied to a text.
- PARSER(Int)             ::
  A parser of ~PARSER(Int)~ type reads chars, and \\
  returns a ~int~ value, when it is applied to a text.
- PARSER(List(Char))      ::
  A parser of ~PARSER(List(Char))~ type reads chars, and \\
  returns a ~List(Char)~ value, when it is applied to a text.
  - *NOTE* :
    - ~PARSER(List(Char))~ is same as ~PARSER(String)~, and
    - ~List(Char)~ is same as ~const char*~.
- PARSER(List(String))    ::
  A parser of ~PARSER(List(String))~ type reads chars, and \\
  returns a ~List(String)~ value, when it is applied to a text.
- PARSER(List(Int))       ::
  A parser of ~PARSER(List(Int))~ type reads chars, and \\
  returns a ~List(int)~ value, when it is applied to a text.

* Built-in Parsers, Parser generators, and Parser combinators
:PROPERTIES:
:CUSTOM_ID: built-in-parsers-parser-generators-and-parser-combinators
:END:

** Built-in Parsers and Parser-generators

- anyChar               :: 
     A PARSER(Char) which parse any one char
- digit                 :: 
     A PARSER(Char) which parse a digit (i.e. ~0~ .. ~9~)
- hexDigit              ::
     A PARSER(Char) which parse a hexadecimal digit (i.e. ~0~ .. ~9~, ~a~ .. ~f~, and ~A~ .. ~F~)
- octDigit              ::
     A PARSER(Char) which parse a octal digit (i.e. ~0~ .. ~7~)
- lower                 :: 
     A PARSER(Char) which parse a lower-case char (i.e. ~a~ .. ~z~)
- upper                 :: 
     A PARSER(Char) which parse a upper-case char (i.e. ~A~ .. ~Z~)
- alpha                 :: 
     A PARSER(Char) which parse an alphabet char (i.e. ~a~ .. ~z~, ~A~ .. ~Z~)
- alnum                 :: 
     A PARSER(Char) which parse a digit or an alphabet char (i.e. ~0~ .. ~9~, ~a~ .. ~z~, ~A~ .. ~Z~)
- letter                :: 
     A PARSER(Char) which parse underscore or an alphabet char (i.e. ~_~, ~a~ .. ~z~, ~A~ .. ~Z~)
- newline               ::
     A PARSER(Char) which parse a newline character (i.e. LF)
- crlf                  ::
     A PARSER(Char) which parse a pair of CR and LF, and returns LF (i.e. CR LF \rightarrow LF)
- endOfLine             ::
     A PARSER(Char) which parse a LF or a CR-LF pair and returns LF.
- tab                   ::
     A PARSER(Char) which parse a TAB character.
- space                 :: 
     A PARSER(Char) which parse a white-space (i.e. space, TAB, LF, CR)
- spaces                :: 
     A PARSER(String) which parse zero or more white-spaces (i.e. space, TAB, LF, CR)
- number                :: 
     A PARSER(Int) which skips leading white-spaces and parse one or more
     subsequent digits then returns it as an ~int~ value when applied to a text.
- char1(c)              :: 
     Create a PARSER(Char) which parse the char ~c~
- string1(s)            :: 
     Create a PARSER(String) which parse the string ~s~.
- oneOf(cs)             :: 
     Create a PARSER(Char) which parse a char ~c~ satisfying it is contained in the string ~cs~.
- noneOf(cs)            :: 
     Create a PARSER(Char) which parse a char ~c~ satisfying it is *not* contained in the string ~cs~.
- satisfy(pred)         :: 
     Create a PARSER(Char) which parse a char ~c~ satisfying ~pred(c) == true~

** Built-in GENERIC Parser-combinators
*** many(p)
- PARSER(List(Char)) many(char c) ::
     Same as ~many(char1(c))~.
- PARSER(List(String)) many(const char* s) ::
     Same as ~many(string1(s))~.

- PARSER(List(T)) many(PARSER(T) p) ::
     Create a parser of PARSER(List(T)) type, which
  - apply ~p~ zeroth or more to a text.
  - return a list consists of the each result of ~p~.
  - if the text was not started with a char sequence expected by ~p~, returns a
    empty list of ~List(T)~ type.
  - *NOTE* : ~T~ must be one of the following:
    - ~Char~
    - ~String~ aka ~List(Char)~
    - ~Int~

*** many1(p)
*NOTE* : ~many1(p)~ is same as ~cons(p, many(p))~.

- PARSER(List(Char)) many1(char c) ::
     Same as ~many1(char1(c))~.
- PARSER(List(String)) many1(const char* s) ::
     Same as ~many1(string1(s))~.

- PARSER(List(T)) many1(PARSER(T) p) ::
     Create a parser of PARSER(List(T)) type, which
  - apply ~p~ once or more to a text.
  - return a list consists of the each result of ~p~.
  - if the text was not started with a char sequence expected by ~p~, throws an
    error of ~p~.
  - *NOTE* : ~T~ must be one of the following:
    - ~Char~
    - ~String~ aka ~List(Char)~
    - ~Int~

*** seq(p, ...)
- PARSER(List(T)) seq(PARSER(T) p, ...) ::
     Create a parser of PARSER(List(T)) type, which
  - apply for all parsers ~p, ...~ to a text.
  - return a list consists of the each retults of ~p, ...~.
  - if a parser in the ~p, ...~ failed, throws an error of it.
  - *NOTE* : For all parser in the ~p, ...~, whose type must be same, otherwise
    the behavior is undefined.
  - *NOTE* : ~T~ must be one of the following:
    - ~Char~
    - ~String~ aka ~List(Char)~
    - ~Int~

*** cons(p, ps)
- PARSER(List(Char)) cons(char c, const char* cs) ::
     Same as ~cons(char1(c), string1(cs))~.
- PARSER(List(Char)) cons(char c, PARSER(List(Char)) ps) ::
     Same as ~cons(char1(c), ps)~.
- PARSER(List(String)) cons(const char* s, PARSER(List(String)) ps) ::
     Same as ~cons(string1(s), ps)~.

- PARSER(List(T)) cons(PARSER(T) p, PARSER(List(T)) ps) ::
     Create a parser of PARSER(List(T)) type, which
  - apply ~p~ at first, and then apply ~ps~ to the subsequent text.
  - return a list consists of the following:
    - the result of ~p~ and
    - elements of the result of ~ps~.
  - if ~p~ or ~ps~ failed, throws an error of it.
  - *NOTE* : ~T~ must be one of the following:
    - ~Char~
    - ~String~ aka ~List(Char)~
    - ~Int~

*** skip1st(p1, p2)
- PARSER(Char) skip1st(char c1, char c2) ::
     Same as ~skip1st(char1(c1), char1(c2))~.
- PARSER(Char) skip1st(const char* s, char c) ::
     Same as ~skip1st(string1(s), char1(c))~.
- PARSER(Char) skip1st(PARSER(S) p, char c) ::
     Same as ~skip1st(p, char1(c))~.
- PARSER(String) skip1st(char c, const char* s) ::
     Same as ~skip1st(char1(c), string1(s))~.
- PARSER(String) skip1st(const char* s1, const char* s2) ::
     Same as ~skip1st(string1(s1), string1(s2))~.
- PARSER(String) skip1st(PARSER(S) p, const char* s) ::
     Same as ~skip1st(p, string1(s))~.
- PARSER(T) skip1st(char c, PARSER(T) p) ::
     Same as ~skip1st(char1(c), p)~.
- PARSER(T) skip1st(const char* s, PARSER(T) p) ::
     Same as ~skip1st(string1(s), p)~.

- PARSER(T) skip1st(PARSER(S) p1, PARSER(T) p2) ::
     Create a parser of PARSER(T) type, which
  - apply ~p1~ at first, and then apply ~p2~ to the subsequent text.
  - return the result of ~p2~ if both ~p1~ and ~p2~ success.
  - if ~p1~ failed, ~p2~ is not applied and throws error of ~p1~.
  - if ~p1~ success and then ~p2~ failed, throws error of ~p2~.
  - *NOTE* : ~S~ and ~T~ must be one of the following:
    - ~Char~
    - ~String~ aka ~List(Char)~
    - ~Int~
    - ~List(String)~
    - ~List(Int)~
  - *NOTE* : ~S~ and ~T~ may or may not be same.\\
    (i.e. ~p1~ and ~p2~ may be a parser of same type or different type)

For example:
#+begin_src c
parseTest(skip1st(char1('a'), string1("bc")), "abc"); // -> "bc"
parseTest(skip1st(string1("ab"), char1('c')), "abc"); // -> 'c'
#+end_src

*** token(p)
*NOTE* : ~token(p)~ is same as ~skip1st(spaces, p)~.

- PARSER(Char) token(char c) ::
     Same as ~token(char1(c))~.
- PARSER(String) token(const char* s) ::
     Same as ~token(string1(c))~.

- PARSER(T) token(PARSER(T) p) ::
     Create a parser of PARSER(T) type, which
  - skip any leading white-spaces,
  - apply ~p~ to the subsequent text, and
  - return the result of ~p~.
  - *NOTE* : ~T~ must be one of the following:
    - ~Char~
    - ~String~ aka ~List(Char)~
    - ~Int~
    - ~List(String)~
    - ~List(Int)~

*** either(p1, p2)
- PARSER(Char) either(char c1, char c2) :: 
     Same as ~either(char1(c1), char1(c2))~.
- PARSER(Char) either(char c, PARSER(Char) p) :: 
     Same as ~either(char1(c), p))~.
- PARSER(Char) either(PARSER(Char) p, char c) :: 
     Same as ~either(p, char1(c)))~.
- PARSER(String) either(const char* s1, const char* s2) :: 
     Same as ~either(string1(s1), string1(s2))~.
- PARSER(String) either(const char* s, PARSER(String) p) :: 
     Same as ~either(string1(s), p)~.
- PARSER(String) either(PARSER(String) p, const char* s) :: 
     Same as ~either(p, string1(s))~.

- PARSER(T) either(PARSER(T) p1, PARSER(T) p2) ::
     Create a parser of PARSER(T) type, which
  - return result of ~p1~ if ~p1~ success,
  - if ~p1~ consumed one or more chars and failed, throw error of ~p1~,
  - if ~p1~ consumed no chars and failed, return result of ~p2~, or
  - throw error of ~p2~
  - *NOTE* : ~T~ must be one of the following:
    - ~Char~
    - ~String~ aka ~List(Char)~
    - ~Int~
    - ~List(String)~
    - ~List(Int)~

*** tryp(p)
- PARSER(Char) tryp(char c) ::
     Same as ~tryp(char1(c))~.
- PARSER(String) tryp(const char* s) ::
     Same as ~tryp(string1(s))~.

- PARSER(T) tryp(PARSER(T) p) ::
     Create a parser of PARSER(T) type, which
  - return result of ~p~ if ~p~ success,
  - otherwise rewind the input-state back then throw error of ~p~.
  - *NOTE* : ~T~ must be one of the following:
    - ~Char~
    - ~String~ aka ~List(Char)~
    - ~Int~
    - ~List(String)~
    - ~List(Int)~


* Building block of Parser-class
:PROPERTIES:
:CUSTOM_ID: building-block-of-parser-class
:END:

** PARSER(T) class

- PARSER(T)             :: 
     Type of parser class. (ex. ~PARSER(Char)~ is ~CharParser~)

** Declare and Define PASER(T) class

- DECLARE_PARSER(T, R)  :: 
     Declare a parser class ~PARSER(T)~, whose instance (i.e. parser of type
     ~PARSER(T)~) return a value of type ~R~ when the parser was applied to a
     text.
- DEFINE_PARSER(T, R) { ~/* print x; */~ } :: 
     Define a parser class ~PARSER(T)~.\\
  - *NOTE* : The trailing block ~{...}~ is body of function ~void SHOW(T)(R x)~.
  - *NOTE* : ~void SHOW(T)(R x)~ is called by ~parseTest(p, text)~ to print ~x~.
  - *NOTE* : ~x~ is the result of parser ~p~ applied to the ~text~.

Example: 'IntParser.h'
#+begin_src c
  #include <cparsec2.h>

  /* declare class PARSER(Int), whose instance return int when applied */
  DECLARE_PARSER(Int, int);
#+end_src

Example: 'IntParser.c'
#+begin_src c
  #include "IntParser.h"

  /* define (implement) class PARSER(Int) */
  DEFINE_PARSER(Int, int) {
    /* implementation of void SHOW(Int)(int x) */
    printf("%d\n", x);
  }
#+end_src

** Construct an instance of PARSER(T) class

- PARSER(T) PARSER_GEN(T)(PARSER_FN(T) f, void* arg) :: 
     Create new instance of ~PARSER(T)~.\\
     ~f~ is used as a function body of the parser instance, and ~arg~ is
     argument to be passed to ~f~ when the parser instance was applied to a
     text.
- PARESR_FN(T)          :: 
     Type of function pointer ~R (*)(void* arg, Source src, Ctx* ex)~.

Example: 'mult.h'
#+begin_src c
  #include "IntParser.h"

  /* a parser generator 'mult(a)' */
  PARSER(Int) mult(int a);
#+end_src

Example: 'mult.c'
#+begin_src c
  #include <stdlib.h>
  #include "IntParser.h"

  /* function body of a parser to be generated by mult(a) */
  static int mult_func(void* arg, Source src, Ctx* ex) {
    int a = (int)(intptr_t)arg;
    return a * atoi(parse(many1(digit), src, ex));
  }

  /* a parser generator 'mult(a)' */
  PARSER(Int) mult(int a) {
    /* construct an instance of PARSER(Int) */
    return PARSER_GEN(Int)(mult_func, (void*)(intptr_t)a);
  }
#+end_src

** Apply an instance of PARSER(T) to a text

To apply a parser, use ~parse(p, src, ctx)~, ~parseTest(p, text)~ and
~PARSE_TEST(p, text)~ macros. These macros are fully generic and easy to use.

In the below example, using ~parse(p, src, ex)~.

Example: 'main.c'
#+begin_src c
  #include <stdio.h>
  #include "mult.h"

  int main(int argc, char** argv) {
    UNUSED(argc);
    UNUSED(argv);

    /* initialize CPARSEC2 library */
    cparsec2_init();

    Ctx ctx;
    TRY(&ctx) {
      /* input text is "100 200" */
      Source src = Source_new("100 200");
      /* parse the input text */
      int x = parse(mult(1), src, &ctx); /* x = 1 * 100 */
      parse(spaces, src, &ctx);          /* skip white-spaces */
      int y = parse(mult(2), src, &ctx); /* y = 2 * 200 */
      /* print x + y */
      printf("%d\n", x + y);
      return 0;
    }
    else {
      printf("error:%s\n", ctx.msg);
      return 1;
    }
  }
#+end_src
