# -*- coding: utf-8-unix -*-
#+STARTUP: showall indent

* An experimental C compiler subset

~excc~ - an experimental C compiler subset - is a sample application using
CPARSEC2 library.
 
~excc~ parses a souce code written in the (subset of) C language, and generates
x86_64 assembly code.

* How to build
#+begin_src shell
make
#+end_src

* Usage

** NAME
excc - an experimental C compiler subset

** SYNOPSIS
*excc* '_source code_'

** DESCRIPTION
Compiles a source code into assembly code of x86_64.

the ~excc~ command
 - takes one argument as the input (a source code),
 - compiles the input into asssembly code, and
 - sends its output (asssembly code) to standard output.

** TARGET
The resulting assembly code generated by ~excc~ is compatible to the following
CPU architecture and ABI (Application Binaly Intarface):
 - CPU architecture ::
      x86_64 (AMD64)
 - ABI (Application Binaly Intarface) ::
      System V ABI (used on GNU/Linux and others)

And the resulting assembly code can be compiled/assembled by the following
compiler/assembler:

| compiler/assembler            | version        | host OS             | target CPU architecture |
|-------------------------------+----------------+---------------------+-------------------------|
| GCC (GNU Compiler Collection) | 7.4.0 or later | Ubuntu 18.04        | x86_64 (AMD64)          |
| GCC (GNU Compiler Collection) | 9.1.0 or later | Msys2               | x86_64 (AMD64)          |
| GCC (GNU Compiler Collection) | 9.2.0 or later | Mingw64 (mingw-w64) | x86_64 (AMD64)          |
- NOTE :: Clang/LLVM is not supported yet.
- NOTE :: Any other OS/CPU not listed in the above won't be supported. (no plan to support them)

Note that the resulting assembly code is for System V ABI, which is not
compatible to Microsoft ABI.

Thus if you were using *Msys2* or *Mingw64* environment on Windows and if your
code was calling to or be called by other C functions (compiled with GCC), the
ABI and calling convention of such functions must be compatible with the System
V ABI.

Using GCC, to specify an ABI (See also the GCC manual):
- specify ~__attribute__((sysv_abi))~ for each function declaration (recommended), or
- use ~-mabi=sysv~ GCC compiler option. (not recommended nor tested)

For example:

*foo.c* (compiled by using ~excc~)
#+begin_src c
  foo(x, y) {
    return x + y;
  }

  main() {
    bar();
    return 0;
  }
#+end_src

*bar.c* (compiled by using ~gcc~)
#+begin_src c
  #include <stdio.h>

  #define ABI __attribute__((sysv_abi))

  ABI int foo(int x, int y);

  ABI int bar(void) {
    printf("%d\n", foo(10, 20));
    return 0;
  }
#+end_src

To compile and execute:
#+begin_src shell
$ ./bin/excc "$(cat foo.c)" > foo.s
$ gcc -o foo foo.s bar.c
$ ./foo
30
$
#+end_src

** EXIT STATUS
If ~excc~ succeeds, it will exit with 0. Otherwise, if an error occurs, it will
exit with a non-zero value.

** EXAMPLE

#+begin_src shell
$ ./bin/excc 'main() { return 10 + 2 * 3; }'
#+end_src

The above command produces the following assembly code:
#+begin_src asm
.intel_syntax noprefix
.global main
main:
  push rbp
  mov rbp, rsp
  sub rsp, 0
  push 10
  push 2
  push 3
  pop rdi
  pop rax
  mul rdi
  push rax
  pop rdi
  pop rax
  add rax, rdi
  push rax
  pop rax
  mov rsp, rbp
  pop rbp
  ret
  mov rsp, rbp
  pop rbp
  ret
#+end_src

So, to make an executable, redirect ~excc~'s output to a file such as ~tmp.s~
and assemble the file by using existence assembler/compiler such as GCC.

Example 1.
#+begin_src shell
$ ./bin/excc 'main() { return 10 + 2 * 3; }' > tmp.s
$ gcc -o tmp tmp.s
$ ./tmp
$ echo $?
16
#+end_src

Example 2.
#+begin_src shell
$ ./bin/excc 'main() { return (10 + 2) * 3; }' > tmp.s
$ gcc -o tmp tmp.s
$ ./tmp
$ echo $?
36
#+end_src

Note that the executable returns the result as its exit status.
- NOTE : ~echo $?~ prints the exit status of the last executed command
- NOTE : Formally, the exit status should be in range of 0 .. 255.
- NOTE : if the executable returned a result out of range, ~echo $?~ cannot
  print correct value. It's not a bug. Don't warry about it.

* Feature
- types ::
  - integer values/variables only.
  - no type declaration is supported yet.
- local variables ::
  - supports multi-character local variables (ex. ~a~, ~abc1~, ~_foobar~)
- global variables ::
  - not supported yet.
- function declaration :: 
  - not supported yet.
- function definition ::
  - type of return value must be ~int~
  - type of any argument must be ~int~
  - zeroth or more arguments are available.
  - variadic arguments is not supported.
  - no type declaration for return value and parmeters
  - e.g. ~foo(x, y) {...}~
- function call ::
  - type of return value must be ~int~
  - type of any argument must be ~int~
  - zeroth or more arguments are available.
  - variadic arguments is not supported.
  - e.g. ~foo(x, y)~
- literal ::
  - decimal integer (ex. ~0~, ~1~, ~100~, ~123456~)
- arithmetic expression ::
  - unary operators
    - optional sign (~+x~ / ~-x~)
  - binary operators
    - add (~x + y~)
    - sub (~x - y~)
    - mul (~x * y~)
    - div (~x / y~)
  - grouping
    - parens (~( expr )~)
- equality expression ::
  - equal (~x == y~)
  - not equal (~x != y~)
- relational expression ::
  - less than (~x < y~)
  - less than or equal (~x <= y~)
  - greater than (~x > y~)
  - greater than or equal (~x >= y~)
- statements ::
  - ~expr ;~
  - ~return expr ;~
  - ~for (expr ; expr ; expr) stmt~
  - ~while (expr) stmt~
  - ~if (expr) stmt~
  - ~if (expr) stmt else stmt~
  - ~{ stmt... }~

* Language syntax

- *Note* : the below is not a strict EBNF since ~comma(,)~, ~semi-colon(;)~, and
  ~white space~ are omitted for ease to read.
#+begin_src c
  program  = toplevel {toplevel} endOfFile
  toplevel = functionDef

  functionDef = ident "(" [par-list] ")" "{" {stmt} "}"
     par-list = ident {"," ident}

  stmt     = expr ";"
           | "return" expr ";"
           | "for" "(" [expr] ";" [expr] ";" [expr] ")" stmt
           | "while" "(" expr ")" stmt
           | "if" "(" expr ")" stmt ["else" stmt]
           | "{" {stmt} "}"
  expr     = assign
  assign   = equality {"=" equality}
  equality = relation {("==" | "!=") relation}
  relation = addsub {("<" | "<=" | ">" | ">=") addsub}
  addsub   = muldiv {("+" | "-") muldiv}
  muldiv   = unary {("*" | "/") unary}
  unary    = ["+" | "-"] term
  term     = "(" expr ")"
           | literal
           | localVariable
           | functionCall

  literal  = number

  localVariable = ident

  functionCall = ident "(" [arg-list] ")"
      arg-list = expr {"," expr}

  ident    = ("_" | alpha){"_" | alnum}
  alnum    = alpha | digit
  alpha    = "a" | "b" | ... | "z" | "A" | "B" | ... | "Z"
  digit    = "0" | "1" | ... "9"
  number   = digit{digit}
#+end_src
