# -*- coding: utf-8-unix -*-
#+STARTUP: showall indent

* An experimental C compiler subset

~excc~ - an experimental C compiler subset - is a sample application using
CPARSEC2 library.
 
~excc~ parses a souce code written in the (subset of) C language, and generates
x86_64 assembly code.

* How to build
#+begin_src shell
make
#+end_src

* Usage

** NAME
excc - an experimental C compiler subset

** SYNOPSIS
*excc* '_source code_'

** DESCRIPTION
Compiles a source code into assembly code of x86_64.

the ~excc~ command
 - takes one argument as the input (a source code),
 - compiles the input into asssembly code, and
 - sends its output (asssembly code) to standard output.

** EXIT STATUS
If ~excc~ succeeds, it will exit with 0. Otherwise, if an error occurs, it will
exit with a non-zero value.

** EXAMPLE

#+begin_src shell
$ ./bin/excc '10 + 2 * 3;'
#+end_src

The above command produces the following assembly code:
#+begin_src asm
.intel_syntax noprefix
.global main
main:
  push rbp
  mov rbp, rsp
  sub rsp, 0
  push 10
  push 2
  push 3
  pop rdi
  pop rax
  mul rdi
  push rax
  pop rdi
  pop rax
  add rax, rdi
  push rax
  pop rax
  mov rsp, rbp
  pop rbp
  ret
#+end_src

So, to make an executable, redirect ~excc~'s output to a file such as ~tmp.s~
and assemble the file by using existence assembler/compiler such as GCC.

Example 1.
#+begin_src shell
$ ./bin/excc '10 + 2 * 3;' > tmp.s
$ gcc -o tmp tmp.s
$ ./tmp
$ echo $?
16
#+end_src

Example 2.
#+begin_src shell
$ ./bin/excc '(10 + 2) * 3;' > tmp.s
$ gcc -o tmp tmp.s
$ ./tmp
$ echo $?
36
#+end_src

Note that the executable returns the result as its exit status.
- NOTE : ~echo $?~ prints the exit status of the last executed command
- NOTE : Formally, the exit status should be in range of 0 .. 255.
- NOTE : if the executable returned a result out of range, ~echo $?~ cannot
  print correct value. It's not a bug. Don't warry about it.

* Feature
- types ::
  - integer values/variables only.
  - no type declaration is supported yet.
- local variables ::
  - supports multi-character local variables (ex. ~a~, ~abc1~, ~_foobar~)
- global variables ::
  - not supported yet.
- functions ::
  - not supported yet.
- literal ::
  - decimal integer (ex. ~0~, ~1~, ~100~, ~123456~)
- arithmetic expression ::
  - unary operators
    - optional sign (~+x~ / ~-x~)
  - binary operators
    - add (~x + y~)
    - sub (~x - y~)
    - mul (~x * y~)
    - div (~x / y~)
  - grouping
    - parens (~( expr )~)
- equality expression ::
  - equal (~x == y~)
  - not equal (~x != y~)
- relational expression ::
  - less than (~x < y~)
  - less than or equal (~x <= y~)
  - greater than (~x > y~)
  - greater than or equal (~x >= y~)
- statements ::
  - ~expr ;~
  - ~return expr ;~
  - ~for (expr ; expr ; expr) stmt~
  - ~while (expr) stmt~
  - ~if (expr) stmt~
  - ~if (expr) stmt else stmt~
  - ~{ stmt... }~

* Language syntax

- *Note* : the below is not a strict EBNF since ~comma(,)~, ~semi-colon(;)~, and
  ~white space~ are omitted for ease to read.
#+begin_src c
  program  = stmt {stmt} endOfFile
  stmt     = expr ";"
           | "{" {stmt} "}"
           | "return" expr ";"
           | "for" "(" [expr] ";" [expr] ";" [expr] ")" stmt
           | "while" "(" expr ")" stmt
           | "if" "(" expr ")" stmt ["else" stmt]
  expr     = assign
  assign   = equality {"=" assign}
  equality = relation {("==" | "!=") relation}
  relation = addsub {("<" | "<=" | ">" | ">=") addsub}
  addsub   = muldiv {("+" | "-") muldiv}
  muldiv   = unary {("*" | "/") unary}
  unary    = ["+" | "-"] term
  term     = "(" expr ")"
           | ident
           | number
  ident    = ("_" | alpha){"_" | alnum}
  alnum    = alpha | digit
  alpha    = "a" | "b" | ... | "z" | "A" | "B" | ... | "Z"
  digit    = "0" | "1" | ... "9"
  number   = digit{digit}
#+end_src
