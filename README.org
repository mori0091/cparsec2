# -*- coding: utf-8-unix -*-
#+STARTUP: showall indent

* CPARSEC2 - a parser combinator library for C language

This project is an exercise to construct *parsec* like library for C11.

- [[#tutorial][Tutorial]]
- [[#api][API]]

** Tutorial
:PROPERTIES:
:CUSTOM_ID: tutorial
:END:

*** How to make your parser

Let's create a parser named ~digit3~, which parses three digits.

**** Step 1. Define function body of your parser.
#+begin_src c
  #include "cparsec2.h"

  StringResult run_digit3(void *arg, Source src) {
    /* omit 'arg' since 'digit3' use no arguments */
    UNUSED(arg);

    Buffer str = buf_new();
    for (int i = 0; i < 3; ++i) {
      CharResult c = parse(digit, src);
      if (c.error) {
        mem_free(str.data);
        return (StringResult){.error = c.error};
      }
      buf_push(&str, c.result);
    }
    return (StringResult){.result = buf_finish(&str)};
  }
#+end_src

**** Step 2. Create parser by calling genParser(fun, arg)
#+begin_src c
  StringParser digit3 = genParser(run_digit3, NULL);
#+end_src

**** Step 3. Then use your parser.
#+begin_src c
  PARSE_TEST(digit3, "1234");   /* -> "123" */
  PARSE_TEST(digit3, "123");    /* -> "123" */
  PARSE_TEST(digit3, "12");     /* -> "error:too short" */
  PARSE_TEST(digit3, "a123");   /* -> "error:not satisfy" */
#+end_src

**** Finally, you can get the 1st example as follows:
#+begin_src c
  #include "cparsec2.h"

  StringResult run_digit3(void *arg, Source src) {
    /* omit 'arg' since 'digit3' use no arguments */
    UNUSED(arg);

    Buffer str = buf_new();
    for (int i = 0; i < 3; ++i) {
      CharResult c = parse(digit, src);
      if (c.error) {
        mem_free(str.data);
        return (StringResult){.error = c.error};
      }
      buf_push(&str, c.result);
    }
    return (StringResult){.result = buf_finish(&str)};
  }

  int main(int argc, char **argv) {
    UNUSED(argc);
    UNUSED(argv);

    /* NOTE: THIS MUST BE CALLED ONCE AT FIRST. */
    cparsec2_init();

    StringParser digit3 = genParser(run_digit3, NULL);
    PARSE_TEST(digit3, "1234");   /* -> "123" */
    PARSE_TEST(digit3, "123");    /* -> "123" */
    PARSE_TEST(digit3, "12");     /* -> "error:too short" */
    PARSE_TEST(digit3, "a123");   /* -> "error:not satisfy" */

    return 0;
  }
#+end_src


*** Simplify your parser by using exception handling
 
Let's rewrite and simplify the ~digit3~ parser by using exception handling.

**** Step 1. Simplify function body of your parser

The following function ~run_digit3ex~ is the simplified version of
~run_digit3()~ (the function body of ~digit3~).

In this example, [[#exception_handling][Exception Handling]] mechanism is used:
- Define ~Ctx ctx~ object
- Use ~TRY(&ctx) {...} else {...}~ (C++, Java like ~try {...} catch {...}~ clause)
- Use ~parseEx(digit, src, &ctx)~ instead of ~parse(digit, src)~

#+begin_src c
  #include "cparsec2.h"

  /* A user-defined parser function. (using exception handling) */
  StringResult run_digit3ex(void *arg, Source src) {
    /* omit 'arg' since 'digit3' use no arguments */
    UNUSED(arg);

    Buffer str = buf_new();
    Ctx ctx;
    TRY(&ctx) {                   /* try */
      for (int i = 0; i < 3; ++i) {
        buf_push(&str, parseEx(digit, src, &ctx));
      }
      return (StringResult){.result = buf_finish(&str)};
    } else {                      /* catch */
      mem_free(str.data);
      return (StringResult){.error = ctx.msg};
    }
  }
#+end_src

**** Step 2. Create parser by calling genParser(fun, arg)

#+begin_src c
  // StringParser digit3 = genParser(run_digit3, NULL);
  StringParser digit3 = genParser(run_digit3ex, NULL);
#+end_src

That's all!


*** You can use 'parser combinator' to make new parser

To make the 1st example ~digit3~ parser, we used pre-defined built-in parser
~digit~. And we made the custom function body such as ~run_digit3()~ or
~run_digit3ex()~ for the ~digit3~ parser...

Is it difficult?

Fortunately, *cparsec2* has various pre-defined /built-in parsers/, /parser
generators/ (factory method to make parser), and /parser combinators/ (factory
method to make parser from other parser(s)).

- built-in parsers      :: 
     ex. ~anyChar~, ~digit~, ~lower~, ~upper~, ~alpha~, ~alnum~, ~letter~, ...
- parser generators     :: 
     factory methods to make (parameterized) parser\\
     ex. ~char1(c)~, ~satisfy(pred)~, ...
- parser combinators    :: 
     factory methods to make (composite) parser from other parser(s)\\
     ex. ~many(p)~, ~many1(p)~, ~seq(p, ...)~, ~cons(p, ps)~, ...

Therefore, we can made the 1st example ~digit3~ more easily, as follows:
#+begin_src c
StringParser digit3 = seq(digit, digit, digit);
#+end_src

That's all !

No need to define a custom function body in case of ~digit3~. Awesome!


** API
:PROPERTIES:
:CUSTOM_ID: api
:END:

*** Core API
- cparsec2_init()       :: 
     Initialize cparsec2 library.\\
     This must be called once at first.
- cparsec2_end()        :: 
     Clean up cparsec2 library. (deallocate all allocated memory)\\
     During after calling this API and before calling ~cparsec2_init()~, calling
     any other cparsec2 API and values returned from them are invalid (access to
     them will be undefined behavior).
- parse(p, src)         :: 
     Apply parser ~p~ to text provided from ~src~, and return result/error as
     struct (such as ~CharResult~, ~StringResult~).
- parseEx(p, src, ctx)  :: 
     Apply parser ~p~ to text provided from ~src~, and return result (such as
     ~char~, ~const char *~). If an error occurred, it is thrown as exception
     through ~ctx~. (see also Exception handling)
- parseTest(p, string)  :: 
     Apply parser ~p~ to ~string~ and print result.
- PARSE_TEST(p, string) :: 
     Same as ~parseTest~ and also print ~p string~. (for debug purpose)
- genParser(f, arg)     :: 
     Create new parser.\\
     ~f~ is a function body of the parser, and ~arg~ is argument (may be NULL)
     to be passed to ~f~ when the parser is applied.

*** Exception handling
:PROPERTIES:
:CUSTOM_ID: exception_handling
:END:

- Ctx                   :: 
     Type of context for exception handling.
- TRY(ctx) {...} else {...} :: 
     Exception handling macro. (C++ or Java like ~try {...} catch {...}~ clause)
- raise(ctx, msg)       :: 
     Throw a string ~msg~ as an exception.

Example:
#+begin_src c
  Ctx ctx;
  TRY(&ctx) {                        /* try */
    // ...
    raise(&ctx, "something wrong!"); /* throw "something wrong!" */
    // ...
  }
  else {                             /* catch */
    printf("error:%s\n", ctx.msg);   /* -> "error: something wrong!" */
    mem_free(ctx.msg);
  }
#+end_src

*** CharParser
- anyChar               :: 
     A CharParser which parse any one char
- digit                 :: 
     A CharParser which parse a digit (i.e. ~0~ .. ~9~)
- lower                 :: 
     A CharParser which parse a lower-case char (i.e. ~a~ .. ~z~)
- upper                 :: 
     A CharParser which parse a upper-case char (i.e. ~A~ .. ~Z~)
- alpha                 :: 
     A CharParser which parse an alphabet char (i.e. ~a~ .. ~z~, ~A~ .. ~Z~)
- alnum                 :: 
     A CharParser which parse a digit or an alphabet char (i.e. ~0~ .. ~9~, ~a~ .. ~z~, ~A~ .. ~Z~)
- letter                :: 
     A CharParser which parse underscore or an alphabet char (i.e. ~_~, ~a~ .. ~z~, ~A~ .. ~Z~)
- char1(c)              :: 
     Create a CharParser which parse the char ~c~
- satisfy(pred)         :: 
     Create a CharParser which parse a char ~c~ satisfying ~pred(c) == true~

*** StringParser
- many(p)               :: 
     Create a StringParser which parse zero or more chars.\\
     A CharParser ~p~ is used to parse for each char.
- many1(p)              :: 
     Create a StringParser which parse one or more chars.\\
     A CharParser ~p~ is used to parse for each char.
- seq(p, ...)           :: 
     Create a StringParser which parse a sequence of chars.\\
     Each CharParser in the list of arguments ~p, ...~ is used to parse for each char.
- cons(p, ps)           :: 
     Create a StringParser which parse a sequence of chars.\\
     A CharParser ~p~ is used to parse the 1st char, and a StringParser ~ps~ is
     used to parse subsequent chars.
