# -*- coding: utf-8-unix -*-
#+STARTUP: showall indent

* CPARSEC2 - a parser combinator library for C language
[[https://circleci.com/gh/mori0091/cparsec2][https://circleci.com/gh/mori0091/cparsec2.svg?style=shield]]
[[https://codecov.io/gh/mori0091/cparsec2][https://codecov.io/gh/mori0091/cparsec2/branch/master/graph/badge.svg]]

This project is an exercise to construct *parsec* like library for C11.

- [[#how-to-build-cparsec2-library][How to build CPARSEC2 library]]
- [[#how-to-build-andor-run-unit-tests][How to build and/or run unit-tests]]
- [[#tutorial][Tutorial]]
- [[#api][API]]

** How to build CPARSEC2 library
:PROPERTIES:
:CUSTOM_ID: how-to-build-cparsec2-library
:END:

In this project, using GNU make command to build and test.\\
Run =make= command as follows. (e.g. type =make= =Enter= at command-line)

To build all: (=bin/cparsec2=, =lib/libcparsec2.a=)
#+begin_src shell
# at the top of project directory
make
#+end_src

To build executable file only: (=bin/cparsec2=)
#+begin_src shell
# at the top of project directory
make build
#+end_src

To build archive file (i.e. library) only: (=lib/libcparsec2.a=)
#+begin_src shell
# at the top of project directory
make lib
#+end_src

To run sample application: (=bin/cparsec2=)
#+begin_src shell
# at the top of project directory
make test
#+end_src

To cleanup:
#+begin_src shell
# at the top of project directory
make clean
#+end_src


** How to build and/or run unit-tests
:PROPERTIES:
:CUSTOM_ID: how-to-build-andor-run-unit-tests
:END:

This project uses [[https://github.com/catchorg/Catch2][Catch2]] - A modern, C++-native, header-only, test framework for
unit-tests.

All unit-tests can be built and/or ran by GNU make command.

To build unit-tests: (=test/tests=)
#+begin_src shell
# at the top of project directory
make -C test
# or at the 'test' directory
cd test
make
#+end_src

To run unit-tests: (=test/tests=)
#+begin_src shell
# at the top of project directory
make test -C test
# or at the 'test' directory
cd test
make test
#+end_src

To cleanup unit-tests:
#+begin_src shell
# at the top of project directory
make clean -C test
# or at the 'test' directory
cd test
make clean
#+end_src


** Tutorial
:PROPERTIES:
:CUSTOM_ID: tutorial
:END:

*** How to make your parser

Let's create a parser named ~digit3~, which parses three digits.

**** Step 1. Define function body of your parser.

In this example, [[#exception_handling][Exception Handling]] mechanism is used:
- Define ~Ctx ctx~ object
- Use ~TRY(&ctx) {...} else {...}~ (C++, Java like ~try {...} catch {...}~ clause)
- Use ~parse(digit, src, &ctx)~

#+begin_src c
  #include "cparsec2.h"

  const char* run_digit3(void* arg, Source src, Ctx* ex) {
    /* omit 'arg' since 'digit3' use no arguments */
    UNUSED(arg);

    Buffer str = buf_new();
    Ctx ctx;
    TRY(&ctx) {                   /* try */
      for (int i = 0; i < 3; ++i) {
        buf_push(&str, parse(digit, src, &ctx));
      }
      return buf_finish(&str);
    }
    else {                        /* catch */
      mem_free(str.data);
      cthrow(ex, ctx.msg);        /* re-throw */
    }
  }
#+end_src

**** Step 2. Create parser by calling genParser(fun, arg)
#+begin_src c
  PARSER(String) digit3 = genParser(run_digit3, NULL);
#+end_src

**** Step 3. Then use your parser.
#+begin_src c
  PARSE_TEST(digit3, "1234");   /* -> "123" */
  PARSE_TEST(digit3, "123");    /* -> "123" */
  PARSE_TEST(digit3, "12");     /* -> "error:too short" */
  PARSE_TEST(digit3, "a123");   /* -> "error:not satisfy" */
#+end_src

**** Finally, you can get the 1st example as follows:
#+begin_src c
  #include "cparsec2.h"

  const char* run_digit3(void* arg, Source src, Ctx* ex) {
    /* omit 'arg' since 'digit3' use no arguments */
    UNUSED(arg);

    Buffer str = buf_new();
    Ctx ctx;
    TRY(&ctx) {                   /* try */
      for (int i = 0; i < 3; ++i) {
        buf_push(&str, parse(digit, src, &ctx));
      }
      return buf_finish(&str);
    }
    else {                        /* catch */
      mem_free(str.data);
      cthrow(ex, ctx.msg);        /* re-throw */
    }
  }

  int main(int argc, char** argv) {
    UNUSED(argc);
    UNUSED(argv);

    /* NOTE: THIS MUST BE CALLED ONCE AT FIRST. */
    cparsec2_init();

    PARSER(String) digit3 = genParser(run_digit3, NULL);
    PARSE_TEST(digit3, "1234");   /* -> "123" */
    PARSE_TEST(digit3, "123");    /* -> "123" */
    PARSE_TEST(digit3, "12");     /* -> "error:too short" */
    PARSE_TEST(digit3, "a123");   /* -> "error:not satisfy" */

    return 0;
  }
#+end_src

*** You can use 'parser combinator' to make new parser

To make the 1st example ~digit3~ parser, we used pre-defined built-in parser
~digit~. And we made the custom function body such as ~run_digit3()~ for the
~digit3~ parser...

Is it difficult?

Fortunately, *cparsec2* has various pre-defined /built-in parsers/, /parser
generators/ (factory method to make parser), and /parser combinators/ (factory
method to make parser from other parser(s)).

- built-in parsers      :: 
     ex. ~anyChar~, ~digit~, ~lower~, ~upper~, ~alpha~, ~alnum~, ~letter~, ...
- parser generators     :: 
     factory methods to make (parameterized) parser\\
     ex. ~char1(c)~, ~satisfy(pred)~, ...
- parser combinators    :: 
     factory methods to make (composite) parser from other parser(s)\\
     ex. ~many(p)~, ~many1(p)~, ~seq(p, ...)~, ~cons(p, ps)~, ...

Therefore, we can made the 1st example ~digit3~ more easily, as follows:
#+begin_src c
  PARSER(String) digit3 = seq(digit, digit, digit);
#+end_src

That's all !

No need to define a custom function body in case of ~digit3~. Awesome!


** API
:PROPERTIES:
:CUSTOM_ID: api
:END:

*** Core API
- cparsec2_init()       :: 
     Initialize cparsec2 library.\\
     This must be called once at first.
- cparsec2_end()        :: 
     Clean up cparsec2 library. (deallocate all allocated memory)\\
     During after calling this API and before calling ~cparsec2_init()~, calling
     any other cparsec2 API and values returned from them are invalid (access to
     them will be undefined behavior).
- parse(p, src, ctx)    :: 
     Apply parser ~p~ to text provided from ~src~, and return result (such as
     ~char~, ~const char *~). If an error occurred, it is thrown as exception
     through ~ctx~. (see also Exception handling)
- parseTest(p, text)    :: 
     Apply parser ~p~ to ~text~ and print result.\\
     Return ~true~ if passed, ~false~ if failed.
- PARSE_TEST(p, text) :: 
     Same as ~parseTest~ and also print ~p text~. (for debug purpose)\\
     Return ~true~ if passed, ~false~ if failed.
- genParser(f, arg)     :: 
     Create new parser instance.\\
     ~f~ is a function body of the parser, and ~arg~ is argument (may be NULL)
     to be passed to ~f~ when the parser is applied.

*** Exception handling
:PROPERTIES:
:CUSTOM_ID: exception_handling
:END:

- Ctx                   :: 
     Type of context for exception handling.
- TRY(ctx) {...} else {...} :: 
     Exception handling macro. (C++ or Java like ~try {...} catch {...}~ clause)
- cthrow(ctx, msg)      :: 
     Throw a string ~msg~ as an exception.

Example:
#+begin_src c
  Ctx ctx;
  TRY(&ctx) {                        /* try */
    // ...
    cthrow(&ctx, "something wrong!"); /* throw "something wrong!" */
    // ...
  }
  else {                             /* catch */
    printf("error:%s\n", ctx.msg);   /* -> "error: something wrong!" */
    mem_free(ctx.msg);
  }
#+end_src

*** CharParser
- anyChar               :: 
     A CharParser which parse any one char
- digit                 :: 
     A CharParser which parse a digit (i.e. ~0~ .. ~9~)
- lower                 :: 
     A CharParser which parse a lower-case char (i.e. ~a~ .. ~z~)
- upper                 :: 
     A CharParser which parse a upper-case char (i.e. ~A~ .. ~Z~)
- alpha                 :: 
     A CharParser which parse an alphabet char (i.e. ~a~ .. ~z~, ~A~ .. ~Z~)
- alnum                 :: 
     A CharParser which parse a digit or an alphabet char (i.e. ~0~ .. ~9~, ~a~ .. ~z~, ~A~ .. ~Z~)
- letter                :: 
     A CharParser which parse underscore or an alphabet char (i.e. ~_~, ~a~ .. ~z~, ~A~ .. ~Z~)
- char1(c)              :: 
     Create a CharParser which parse the char ~c~
- satisfy(pred)         :: 
     Create a CharParser which parse a char ~c~ satisfying ~pred(c) == true~

*** StringParser
- spaces                :: 
     A StringParser which parse zero or more whitespaces (i.e. space, TAB, LF, CR)
- many(p)               :: 
     Create a StringParser which parse zero or more chars.\\
     A CharParser ~p~ is used to parse for each char.
- many1(p)              :: 
     Create a StringParser which parse one or more chars.\\
     A CharParser ~p~ is used to parse for each char.
- seq(p, ...)           :: 
     Create a StringParser which parse a sequence of chars.\\
     Each CharParser in the list of arguments ~p, ...~ is used to parse for each char.
- cons(p, ps)           :: 
     Create a StringParser which parse a sequence of chars.\\
     A CharParser ~p~ is used to parse the 1st char, and a StringParser ~ps~ is
     used to parse subsequent chars.
- string1(s)            :: 
     Create a StringParser which parse the given string.\\
     The string ~s~ is used as expectation to parse a string.

*** TokenParser
- token(type, p)        :: 
     Create a TokenParser which parse a token.\\
     An enum TokenType ~type~ specify the kind of token, and ~p~ is used to
     parse a token string.
  - NOTE: Resulting TokenParser skips any leading whitespaces and then parse
    subsequent chars by using ~p~.
  - NOTE: Type of ~p~ shall be one of the following:
    - ~char~
    - ~const char*~ ; must be ends with null character (i.e. string)
    - ~CharParser~
    - ~StringParser~
  - NOTE: ~token(type, p)~ is *experimental*. Maybe API will be changed.

*** Building block of PARSER(T) class

**** PARSER(T) class

- PARSER(T)             :: 
     Type of parser class. (ex. ~PARSER(Char)~ is ~CharParser~)

**** Declare and Define PASER(T) class

- DECLARE_PARSER(T, R)  :: 
     Declare a parser class ~PARSER(T)~, whose instance return a value of type
     ~R~ when the parser was applied to a text.
- DEFINE_PARSER(T, R) { ~/* print x; */~ } :: 
     Define a parser class ~PARSER(T)~.\\
  - NOTE: The trailing block ~{...}~ is body of function ~void SHOW(T)(R x)~.
  - NOTE: ~void SHOW(T)(R x)~ is called by ~PARSETEST(T)(msg, p, src)~ to print ~x~.
  - NOTE: ~x~ is the result of ~PARSE(T)(p, src, ex)~.

Example: 'IntParser.h'
#+begin_src c
  #include <cparsec2.h>

  /* declare class PARSER(Int), whose instance return int when applied */
  DECLARE_PARSER(Int, int);
#+end_src

Example: 'IntParser.c'
#+begin_src c
  #include "IntParser.h"

  /* define (implement) class PARSER(Int) */
  DEFINE_PARSER(Int, int) {
    /* implementation of void SHOW(Int)(int x) */
    printf("%d\n", x);
  }
#+end_src

**** Construct an instance of PARSER(T) class

- PARSER(T) PARSER_GEN(T)(PARSER_FN(T) f, void* arg) :: 
     Create new instance of ~PARSER(T)~.\\
     ~f~ is used as a function body of the parser instance, and ~arg~ is
     argument to be passed to ~f~ when the parser instance was applied to a
     text.
- PARESR_FN(T)          :: 
     Type of function pointer ~R (*)(void* arg, Source src, Ctx* ex)~.

Example: 'mult.h'
#+begin_src c
  #include "IntParser.h"

  /* a parser generator 'mult(a)' */
  PARSER(Int) mult(int a);
#+end_src

Example: 'mult.c'
#+begin_src c
  #include <stdlib.h>
  #include "IntParser.h"

  /* function body of a parser to be generated by mult(a) */
  static int mult_func(void* arg, Source src, Ctx* ex) {
    int a = (int)(intptr_t)arg;
    return a * atoi(PARSE(String)(many1(digit), src, ex));
  }

  /* a parser generator 'mult(a)' */
  PARSER(Int) mult(int a) {
    /* construct an instance of PARSER(Int) */
    return PARSER_GEN(Int)(mult_func, (void*)(intptr_t)a);
  }
#+end_src

**** Apply an instance of PARSER(T) to a text

- R PARSE(T)(PARSER(T) p, Source src, Ctx* ctx) :: 
     Apply parser ~p~ to text provided from ~src~, and return result of type
     ~R~. If an error occurred, it is thrown as exception through ~ctx~. (see
     also Exception handling)
- bool PARSETEST(T)(const char* msg, PARSER(T) p, const char* text) :: 
     Apply parser ~p~ to ~text~ and print ~msg~ follows result.\\
     Return ~true~ if passed, ~false~ if failed.

Example: 'main.c'
#+begin_src c
  #include <stdio.h>
  #include "mult.h"

  int main(int argc, char** argv) {
    UNUSED(argc);
    UNUSED(argv);

    /* initialize CPARSEC2 library */
    cparsec2_init();

    Ctx ctx;
    TRY(&ctx) {
      /* input text is "100 200" */
      Source src = Source_new("100 200");
      /* parse the input text */
      int x = PARSE(Int)(mult(1), src, &ctx); /* x = 1 * 100 */
      PARSE(String)(spaces, src, &ctx);       /* skip white-spaces */
      int y = PARSE(Int)(mult(2), src, &ctx); /* y = 2 * 200 */
      /* print x + y */
      printf("%d\n", x + y);
      return 0;
    }
    else {
      printf("error:%s\n", ctx.msg);
      return 1;
    }
  }
#+end_src
